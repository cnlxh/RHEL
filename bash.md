# Bash基本功能

bash是 `Bourne-Again Shell` 的缩写，用于在计算机上解释用户命令

## bash 语法

### 注释

所有#开头的行，一般都会当作注释，不予真实执行

引号

引号可用于禁用对特殊字符的特殊处理，以防止保留字被识别为保留字，并防止参数扩展，有三种机制： 转义字符 、单引号和双引号

### 转义字符

不加引号的转义字符（\）主要是用来保留其后跟着的字面值，如果不加引号的转义字符在命令行尾部多次出现，一般用于折行，bash处理时，将视为同一行

### 单引号

将字符括在单引号中可保留引号内每个字符的字面值，单引号之间不能出现单引号，即使前面有反斜杠也是如此

### 双引号

将字符括在双引号中也可以保留引号内所有字符的文字值，但以下字符将会有特殊意义：

1. $
2. `
3. !
4. /

# SHELL 命令

简单的shell语法格式：命令+空格+参数

更复杂的 shell 命令由以多种方式排列在一起的简单命令组成：在管道中，一个命令的输出成为第二个命令的输入

## 保留关键字

保留关键字是对 shell 具有特殊含义的单词，以下字符在不加引号时被识别为保留


| `if`   | `then` | `elif`   | `else`   | `fi`       | `time` |
| -------- | -------- | ---------- | ---------- | ------------ | -------- |
| `for`  | `in`   | `until`  | `while`  | `do`       | `done` |
| `case` | `esac` | `coproc` | `select` | `function` |          |
| `{`    | `}`    | `[[`     | `]]`     | `!`        |          |

## 管道符

管道中每个命令的输出通过管道连接到下一个命令的输入。也就是说，每个命令都会读取前一个命令的输出

样例：

```bash
cat filename | wc -l
```

如果管道后面是|&，将会把管道前面的标准错误输出附加给后一个命令，这是2>&1的缩写用法

## 命令列表
1. 通常情况下，多个命令可以用; 、&、&&、|| 来做为结束符进行分割
2. &&和||以及；和&具有同等优先级，
3. 列表中可能出现一个或多个换行符序列，用于分隔命令，相当于分号
4. & 出现在命令最后的时候，将会被放到后台子shell中异步执行命令，并返回状态码0
5. 以';'分隔的命令按顺序执行;shell等待每个命令依次终止。返回状态是最后执行的命令的退出状态
6. AND和OR列表是一个或多个管道的序列，分别由控制操作符' && '和' || '分隔。AND和OR列表以左结合的方式执行

    举例说明:

    AND: 当且仅当command1返回退出状态为0(成功)时，Command2将被执行
    ```bash
    command1 && command2
    ```
    OR: 当且仅当command1返回非零退出状态时，Command2将被执行
    ```bash
    command1 || command2
    ```
## 复合命令
复合命令是shell编程语言的构造。每个构造以保留字或控制操作符开始，并以相应的保留字或操作符结束。与复合命令关联的任何重定向都适用于该复合命令中的所有命令，除非显式覆盖。

在大多数情况下，复合命令描述中的命令列表可以用一个或多个换行符与命令的其余部分隔开，并可以在后面用换行符代替分号。

Bash提供了循环构造、条件命令和将命令分组并作为一个单元执行的机制

### 循环
Bash支持以下循环结构
1. until

只要`systemctl is-active tmp.mount`的退出状态不为零，就执行`echo tmp.mount is not start`。返回状态是在until中执行的最后一个命令的退出状态，如果没有执行，则为零
```bash
until systemctl is-active tmp.mount &> /dev/null;do echo tmp.mount is not start;done
```

2. while

只要`systemctl is-active tmp.mount`的退出状态为零，就执行`echo tmp.mount is active`。返回状态是在while中执行的最后一个命令的退出状态，如果没有执行，则为零

```bash
while systemctl is-active tmp.mount &> /dev/null ;do echo tmp.mount is active;done
```
3. for

展开*单词*，并为结果列表中的每个成员执行一次命令，将名称绑定到当前成员。如果`in words`不存在，for命令将为每个设置的位置参数执行一次命令，就像`in "$@"`已经指定了一样

返回状态是最后执行的命令的退出状态。如果展开的单词中没有项，则不执行任何命令，返回状态为零。

```bash
for number in 1 2 3 4 5;do echo $number;done
```
```bash
for i in $(command) #可以执行命令，把结果分别复制到i
```

下面例子中，没有为param指定列表，所以它将会打印所有传入的位置参数
```bash
for param; do
    echo "$param "
done
```
还支持for命令的另一种形式:

首先，根据下面描述的规则计算算术表达式expr1。然后对算术表达式expr2重复求值，直到它求值为零。每当expr2求值为非零值时，就执行命令并计算算术表达式expr3。如果省略任何表达式，它的行为就好像它的计算结果是1。返回值是所执行命令中最后一个命令的退出状态，如果表达式无效，则返回值为false

```bash
for (( expr1 ; expr2 ; expr3 )) ; do commands ; done
```
break和continue内建函数可以用来控制循环执行

### 条件结构

1. if

if将会依次执行判断，如果第一次判断返回值是0，就不再向下判断，返回这非0，会不断向下判断，直到遇到0，如果都不匹配，就会执行else
```bash
if [ 1 > 2 ]; then
    echo that not ok
elif [ 2 > 1 ]; then
    echo elif 2 > 1 ok
elif [ 3 < 4 ]; then
    echo elif 3 < 4 ok
else
    echo error
fi
```

2. case

Case将有选择地执行与第一个匹配word的模式对应的命令列表。根据模式匹配中描述的规则执行匹配。模式列表和相关联的命令列表称为子句

每个子句必须以';;'，';& '，或';;& '结束。在尝试匹配之前，该单词要进行波浪展开、参数展开、命令替换、算术展开和引号删除。每个模式都经历了波浪展开、参数展开、命令替换、算术展开、过程替换和引号删除。

可以有任意数量的case子句，每个子句以';;'，';& '或';;& '结束。匹配的第一个模式决定执行的命令列表。通常使用' * '作为定义默认情况的最终模式，因为该模式总是匹配的。

下面是一个脚本用例，可以用来描述动物的一个有趣的特征:

```bash
echo -n "Enter the name of an animal: "
read ANIMAL
echo -n "The $ANIMAL has "
case $ANIMAL in
  horse | dog | cat) echo -n "four";;
  man | kangaroo ) echo -n "two";;
  *) echo -n "an unknown number of";;
esac
echo " legs."
```

- 如果使用';;'操作符，则在第一个模式匹配之后不再尝试后续匹配
- 使用';& '代替';;'导致执行继续执行与下一个子句(如果有的话)相关联的命令列表
- 使用';;& '代替';;'会导致shell测试下一个子句中的模式(如果有的话)，并在成功匹配的情况下执行任何关联的命令列表，继续执行case语句，就像模式列表没有匹配一样

如果没有匹配的模式，返回状态为零。否则，返回状态为所执行命令列表的退出状态

3. select

select允许简单地生成菜单。它的语法与for命令几乎相同:

```bash
PS3='choose one: '
echo

select var in {A..D}
do
    echo
    echo "your choose is $var"
    echo "OK"
    echo
    break
done
```
后面的单词列表被展开，生成项目列表，展开的单词集打印在标准错误输出流上，每个单词前面都有一个数字。如果省略`in words`，则打印位置参数，就像`in "$@"`被指定了一样。select然后显示PS3提示符，并从标准输入中读取一行。如果该行包含一个与显示的单词之一对应的数字，则将name的值设置为该单词。如果该行为空，则重新显示文字和提示符。如果读取EOF，则select命令完成并返回1。任何其他读取的值都会导致name被设置为null。读取的行保存在变量REPLY中

这些命令在每次选择之后执行，直到执行一个break命令，此时select命令完成。

下面是一个示例，它允许用户从当前目录中选择文件名，并显示所选文件的名称和索引。

```bash
select fname in *;
do
	echo you picked $fname \($REPLY\)
	break;
done
```

- ((…))

算术表达式根据下面描述的规则求值。表达式进行了与双引号内相同的展开，但表达式中的双引号字符不会被特别处理，会被删除。如果表达式的值非零，则返回状态为0;否则返回状态为1。
```bash
(( expression ))
```

- [[…]]

```bash
[[ expression ]]
```

根据条件表达式表达式的求值，返回0或1的状态。表达式由Bash条件表达式中描述的主要元素组成。[[ and ]]之间的单词不进行分词和文件名展开。shell对这些单词执行波浪展开、参数和变量展开、算术展开、命令替换、过程替换和引号删除(如果单词用双引号括起来，就会进行展开)。像`-f`这样的条件运算符必须不加引号才能被识别为主运算符

当与[[一起使用时，' < '和' > '操作符使用当前位置按字典顺序排序

当' == '和'!='操作符使用时，则操作符右侧的字符串被认为是一个模式，并根据模式匹配中描述的规则进行匹配，' = '操作符与' == '相同。如果字符串匹配(' == ')或不匹配(' != ')模式，则返回值为0，否则返回值为1

如果使用shell的任何引用机制引用模式的任何部分，则按字面意思匹配被引用的部分。这意味着引号部分中的每个字符都匹配自身，而不是具有任何特殊的模式匹配含义

还有一个额外的二进制运算符' =~ '可用，其优先级与' == '和' != '相同。当您使用' =~ '时，操作符右侧的字符串被认为是POSIX扩展正则表达式模式并进行相应的匹配(使用通常在regex(3)中描述的POSIX regcomp和regexec接口)。如果字符串匹配模式则返回值为0，如果不匹配则返回值为1。如果正则表达式语法错误，则条件表达式返回2

您可以引用模式的任何部分，以强制按字面来匹配被引用的部分，而不是作为正则表达式(参见上面)。如果模式存储在shell变量中，引用变量展开将强制按字面意思匹配整个模式。

如果匹配字符串的任何部分，该模式就会匹配。如果您想强制模式匹配整个字符串，可以使用' ^ '和' $ '正则表达式操作符锚定模式。

例如，如果值的任何位置有一个字符序列，由空格字符类中的任意数字组成，包括0，紧跟着0或1个' a '实例，然后是' b '，则下面的语句将匹配一行(存储在shell变量line中):

```bash
[[ $line =~ [[:space:]]*(a)?b ]]
```
这意味着诸如' aab '、' aaaaaab '、' xaby '和' ab '等行的值都将匹配，就像值中任何地方都包含' b '的行一样

如果您想匹配正则表达式语法特有的字符(' ^$|[]()\.*+? ')，则必须对其加引号以去除其特殊含义。这意味着在'xxx.txt'模式中，'.' 将匹配字符串中的任何字符(它通常的正则表达式含义)，但在模式'"xxx.txt"'中，它只能匹配文本

同样，如果希望在模式中包含对正则表达式语法具有特殊意义的字符，则必须确保它没有被引用。例如，如果您想在字符串的开头或结尾锚定一个模式，就不能使用任何形式的shell引用' ^ '或' $ '字符。

如果你想在一行的开始匹配' initial string '，下面将工作:
```bash
[[ $line =~ ^"initial string" ]]
```
但这将不工作
```bash
[[ $line =~ "^initial string" ]]
```

因为在第二个例子中' ^ '被引用了，没有它通常的特殊含义。

有时很难在不使用引号的情况下正确指定正则表达式，或者在注意shell引号和shell的引号删除的同时跟踪正则表达式使用的引号。在shell变量中存储正则表达式通常是避免引用shell特有字符的问题的一种有效方法。例如，以下等价于上面使用的模式:
```bash
pattern='[[:space:]]*(a)?b'
[[ $line =~ $pattern ]]
```

Shell程序员应该特别注意反斜杠，因为Shell和正则表达式都使用反斜杠来删除下面字符的特殊含义。这意味着在shell的单词扩展完成之后，模式中最初没有引用的部分中保留的任何反斜杠都可以删除模式字符的特殊含义。如果模式的任何部分被引用，shell将尽最大努力确保正则表达式将其余的反斜杠视为文字，如果它们出现在引用的部分中。

以下两组命令是不相等的:
```bash
pattern='\.'

[[ . =~ $pattern ]]
[[ . =~ \. ]]

[[ . =~ "$pattern" ]]
[[ . =~ '\.' ]]
```

前两个匹配会成功，但后两个不会，因为在后两个反斜杠将是要匹配的模式的一部分。在前两个示例中，传递给正则表达式解析器的模式是' \. '。反斜杠去掉'.'的特殊含义。所以字面意思'.'匹配。在第二个两个例子中，传递给正则表达式解析器的模式带有反斜杠(例如，' \\\. ')，这将不匹配字符串，因为它不包含反斜杠。如果第一个例子中的字符串不是'.’，而是‘a’，模式不匹配，因为引用了‘.’就失去了匹配任何单个字符的特殊意义。

正则表达式中的括号表达式也可能是错误的来源，因为正则表达式中通常具有特殊含义的字符在括号之间失去了特殊含义。但是，您可以使用括号表达式来匹配特殊的模式字符，而不需要引用它们，因此它们有时在此用途上很有用。

尽管它看起来像是一种奇怪的书写方式，但下面的模式将匹配'.'在字符串中:
```bash
[[ . =~ [.] ]]
```

## SHELL 函数
函数的声明使用以下语法:
```bash
fname () compound-command [ redirections ]
```
OR

```bash
function fname [()] compound-command [ redirections ]
```
这定义了一个名为fname的shell函数。保留字function是可选的。如果提供了function保留字，则括号是可选的，在默认模式下，函数名可以是任何不包含' $ '的不加引号的shell单词

如果在函数中执行了内置命令return，则函数完成，函数调用后的下一个命令将继续执行，如果给return函数一个数值参数，那就是函数的返回状态;否则，函数的返回状态是在返回之前执行的最后一个命令的退出状态

如果一个变量var在函数func1中被声明为局部变量，而func1调用另一个函数func2，那么从func2中对var的引用将解析为来自func1的局部变量var，从而掩盖任何名为var的全局变量。

可以使用unset来取消变量

```bash
func1()
{
    local var='func1 local'
    func2
}

func2()
{
    echo "In func2, var = $var"
}

var=global
func1
```

## SHELL参数
1. 位置参数

位置参数在调用shell时从shell的参数中赋值，并且可以使用set内置命令重新赋值。位置参数N可以被引用为${N}，或者当N由单个数字组成时被引用为$N。位置参数不能用赋值语句赋值。set和shift内置函数用于设置和取消设置它们，在执行shell函数时，位置参数会被临时替换

当包含多个数字的位置参数展开时，必须用大括号括起来

2. 特殊的参数

- $*

\$* 位置参数，从1开始。当不在双引号内时，每个位置参数展开为单独的单词。出现在双引号内时，它展开为单个单词

- $@

\$@ 位置参数，从1开始。如果不在双引号内，这些词就会被分词，每个位置参数由空格分隔。当发生在双引号内，并执行单词拆分时，每个参数也展开为一个单独的单词。也就是说，“$@”相当于“$1”“$2”....

\$*和$@，没有双引号的时候没有区别，有双引号的时候，\$\*会把所有位置参数识别为一个整体，而\$@依旧会识别为单个单词

- $?

$?展开到最近执行的前台管道的退出状态

- \$$

($$)扩展到shell的进程号。在子shell中，它展开到调用shell的进程ID，而不是子shell。

- $!

$!展开到最近放置到后台的作业的进程ID，无论是作为异步命令执行还是使用bg

- $0

展开为shell或shell脚本的名称。这是在shell初始化时设置的。如果使用命令文件调用Bash，则将$0设置为该文件的名称。如果Bash以-c选项开始那么$0将被设置为要执行的字符串后面的第一个参数(如果存在的话)。否则，它将被设置为用于调用Bash的文件名，如参数0所给出的那样

# 内置命令

- break

退出for, while, until, select 循环，如果使用的是break n，这个n是退出几级嵌套的意思，不指定n，那这个n就是1

- continue

恢复for, while, until, select的下一次迭代，同样支持n，n要大于1

- eval

这些参数被连接到一个命令中，然后读取和执行该命令，并将其退出状态作为eval的退出状态返回。如果没有参数或只有空参数，则返回状态为零

- exec

如果提供了命令，它将替换shell而不创建新进程。如果提供了-l选项，shell将在传递给命令的第0个参数的开头放置破折号。这就是登录程序所做的。-c选项将导致在空环境下执行命令。如果提供了-a, shell将name作为第0个参数传递给command。如果由于某种原因不能执行命令，则退出非交互式shell，除非启用了execfail shell选项。在这种情况下，它返回失败。如果文件无法执行，交互式shell将返回失败。如果exec失败，子shell将无条件退出。如果没有指定命令，则可能使用重定向来影响当前shell环境。如果没有重定向错误，返回状态为零;否则返回状态为非零。

- export

赋值变量，并传递到所有的子进程

- readonly

将变量标记为只读
```bash
readonly abc=456
```

- return

使 shell 函数停止执行并将值返回给其调用方

- let

对 shell 变量执行算术运算

```bash
let expression [expression …]
```

- local

创建一个局部变量，并赋值

- printf

```bash
printf [-v var] format [arguments]
```

将参数格式化后写入标准输出

- read

从标准输入中读取一行，或从作为选项的参数提供的文件描述符中读取

